<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</head>
<body>
<div id="TOC">
<ul>
<li><a href="#introduction"><span class="toc-section-number">1</span> Introduction</a></li>
<li><a href="#installation"><span class="toc-section-number">2</span> Installation</a></li>
<li><a href="#creating-users-and-connections"><span class="toc-section-number">3</span> Creating Users and Connections</a></li>
<li><a href="#managing-databases"><span class="toc-section-number">4</span> Managing Databases</a></li>
<li><a href="#creating-changing-and-removing-tables"><span class="toc-section-number">5</span> Creating, Changing and Removing Tables</a></li>
<li><a href="#managing-table-data"><span class="toc-section-number">6</span> Managing Table Data</a></li>
<li><a href="#writing-sql-queries"><span class="toc-section-number">7</span> Writing SQL Queries</a></li>
<li><a href="#visualizing-query-plans"><span class="toc-section-number">8</span> Visualizing Query Plans</a></li>
<li><a href="#visualizing-data"><span class="toc-section-number">9</span> Visualizing Data</a></li>
<li><a href="#managing-other-elements"><span class="toc-section-number">10</span> Managing other Elements</a></li>
<li><a href="#additional-features"><span class="toc-section-number">11</span> Additional Features</a></li>
<li><a href="#omnidb-config-tool"><span class="toc-section-number">12</span> OmniDB Config Tool</a></li>
<li><a href="#writing-and-debugging-plpgsql-functions"><span class="toc-section-number">13</span> Writing and Debugging PL/pgSQL Functions</a></li>
<li><a href="#monitoring-dashboard"><span class="toc-section-number">14</span> Monitoring Dashboard</a></li>
<li><a href="#logical-replication"><span class="toc-section-number">15</span> Logical Replication</a></li>
<li><a href="#pglogical"><span class="toc-section-number">16</span> pglogical</a></li>
<li><a href="#postgres-bdr"><span class="toc-section-number">17</span> Postgres-BDR</a></li>
<li><a href="#postgres-xl"><span class="toc-section-number">18</span> Postgres-XL</a></li>
</ul>
</div>
<h1 id="introduction"><span class="header-section-number">1</span> Introduction</h1>
<p><strong>OmniDB</strong> is an open source browser-based app designed to access and manage many different Database Management systems, e.g. PostgreSQL, Oracle and MySQL. OmniDB can run either as an App or via Browser, combining the flexibility needed for various access paths with a design that puts security first. OmniDB is actively developed, automatically tested on a variety of databases and browsers and comes with full documentation.</p>
<p>Since early development, OmniDB was designed as an browser-based app. Consequently, it runs in any browser, from any operational system. It can be accessed by several computers and multiple users, each one of them with his/her own group of connections. It also can be hosted in any operational system, without the need of install any dependencies. We will see further details on installation in the next chapters.</p>
<p>OmniDB’s main objective is to offer an unified workspace with all functionalities needed to manipulate different DMBS. DBMS specific tools aren’t required: in OmniDB, the context switch between different DBMS is done with a simple connection switch, without leaving the same page. The end-user’s sensation is that there is no difference when he/she manipulates different DBMS, it just feels like different connections.</p>
<p>Despite this, OmniDB is built with simplicity in mind, designed to be a fast and lightweight browser-based application. OmniDB is also powered by the WebSocket technology, allowing the user to execute multiple queries and procedures in multiple databases in multiple hosts in background.</p>
<p>OmniDB is also secure. All OmniDB user data are stored encrypted, and no database password is stored at all. When the user first connects to a database, OmniDB asks for the password. This password is encrypted and stored in memory for a specific amount of time. When this time expires, OmniDB asks the password again. This ensures maximum security for the database OmniDB is connecting to.</p>
<h4 id="history"><span class="header-section-number">1.0.0.1</span> History</h4>
<p><strong>OmniDB</strong>’s creators, Rafael Thofehrn Castro and William Ivanski, worked in a company where they needed to deal with several different databases from customers on a daily basis. These databases were from different DBMS technologies, and so they needed to keep switching between database management tools (typically one for each DBMS). As they were not keen of the existing unified database management tools (that could manage different DBMS), they came up with OmniDB’s main idea.</p>
<p><strong>OmniDB</strong>’s first version was presented as an undergrad final project in the Computer Science Course from the Federal University of Paraná, in Brazil. The objective was to trace a common line between popular DBMS, and to study deeply their <em>metadata</em>. The result was a tool written in ASP.NET/C# capable of connecting and identifying the main structures (tables, keys, indexes and constraints), in a generic way, from several DBMS:</p>
<ul>
<li>Firebird</li>
<li>MariaDB / MySQL</li>
<li>Oracle</li>
<li>PostgreSQL</li>
<li>SQLite</li>
<li>Microsoft SQL Server</li>
</ul>
<p>OmniDB’s first version also allowed the conversion between all DBMSs supported by the tool. This feature was developed to be user friendly, requiring just a few steps: the user needs to select a source connection, the structures that will be converted (just tables and all their structures, along with their data) and the target connection.</p>
<h1 id="installation"><span class="header-section-number">2</span> Installation</h1>
<p>OmniDB provides 2 kinds of packages to fit every user needs:</p>
<ul>
<li><strong>OmniDB Application</strong>: Runs a web server on a random port behind, and provides a simplified web browser window to use OmniDB interface without any additional setup. Just feels like a desktop application.</li>
<li><strong>OmniDB Server</strong>: Runs a web server on a random port. User needs to connect to it through a web browser. Provides user management, ideal to be hosted on a server on users' networks.</li>
</ul>
<p>Both application and server can be installed on the same machine.</p>
<h4 id="omnidb-application"><span class="header-section-number">2.0.0.1</span> OmniDB Application</h4>
<p>In order to run OmniDB app, you don't need to install any additional piece of software. Just head to <a href="omnidb.org" class="uri">omnidb.org</a> and download the latest package for your specific operating system and architecture:</p>
<ul>
<li>Linux 32 bits / 64 bits
<ul>
<li>DEB installer</li>
<li>RPM installer</li>
</ul></li>
<li>Windows 32 bits / 64 bits
<ul>
<li>EXE installer</li>
</ul></li>
<li>Mac OSX
<ul>
<li>DMG installer</li>
</ul></li>
</ul>
<p>Use the specific installer for your Operational System and it will be available through your desktop environment application menu or via command line with <code>omnidb-app</code>.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_001.png" /></p>
<h4 id="omnidb-server"><span class="header-section-number">2.0.0.2</span> OmniDB Server</h4>
<p>Like OmniDB app, OmniDB server doesn't require any additional piece of software and the same options for operating system and architecture are provided.</p>
<p>Use the specific installer for your Operational System and it will be available through command line with <code>omnidb-server</code>:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">user@machine</span>:~$ omnidb-server
<span class="ex">Starting</span> OmniDB server...
<span class="ex">Checking</span> port availability...
<span class="ex">Starting</span> server OmniDB 2.4.0 at 0.0.0.0:8000.
<span class="ex">Starting</span> migration of user database from version 0.0.0 to version 2.4.0
<span class="ex">OmniDB</span> successfully migrated user database from version 0.0.0 to version 2.4.0
<span class="ex">Press</span> Ctrl+C to exit</code></pre></div>
<p>Note how OmniDB starts a <em>web server</em> in port 8000. You can also specify web server port and listening address:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">user@machine</span>:~$ omnidb-server -p 8080 -H 127.0.0.1
<span class="ex">Starting</span> OmniDB server...
<span class="ex">Checking</span> port availability...
<span class="ex">Starting</span> server OmniDB 2.4.0 at 0.0.0.0:8080.
<span class="ex">Starting</span> migration of user database from version 0.0.0 to version 2.4.0
<span class="ex">OmniDB</span> successfully migrated user database from version 0.0.0 to version 2.4.0
<span class="ex">Press</span> Ctrl+C to exit</code></pre></div>
<h4 id="omnidb-with-oracle"><span class="header-section-number">2.0.0.3</span> OmniDB with Oracle</h4>
<p>OmniDB app and server does not require any piece of additional software, as explained above. But if you are going to connect to an <em>Oracle</em> database, then you need to download and extract <em>Oracle Instant Client</em> into OmniDB's folder (<code>/opt/omnidb-app</code> if you are using app version or <code>/opt/omnidb-server</code> if you are using server version) or into <code>~/lib</code>, depending on the operating system you use: - <strong>MacOSX</strong>: Download Oracle Instant Client (<a href="http://www.oracle.com/technetwork/topics/intel-macsoft-096467.html">64-bit</a>) and extract in <code>~/lib</code>; - <strong>Linux</strong>: Download Oracle Instant Client (<a href="http://www.oracle.com/technetwork/topics/linuxsoft-082809.html">32-bit</a>) (<a href="http://www.oracle.com/technetwork/topics/linuxx86-64soft-092277.html">64-bit</a>) and extract it into OmniDB's folder; - <strong>Windows</strong>: Download Oracle Instant Client (<a href="http://www.oracle.com/technetwork/topics/winsoft-085727.html">32-bit</a>) (<a href="http://www.oracle.com/technetwork/topics/winx64soft-089540.html">64-bit</a>) and extract it into OmniDB's folder.</p>
<p>If you already have an Oracle Instant Client installed and loaded into your lib path, then OmniDB will be able to use it, and you will not need to download it and extract it into a specific folder again.</p>
<h4 id="omnidb-user-database"><span class="header-section-number">2.0.0.4</span> OmniDB User Database</h4>
<p>Since version 2.4.0, upon initialization both server and app will create a file <code>~/.omnidb/omnidb-app/omnidb.db</code> (for OmniDB app) or <code>~/.omnidb/omnidb-server/omnidb.db</code> (for OmniDB server) in the user home directory, if it does not exist. That can be confirmed by the message <em>OmniDB successfully migrated user database from version 0.0.0 to version 2.4.0</em> you saw above. This file is also called <strong>user database</strong> and contains user data. If it already exists, then OmniDB will check whether the version of the server matches the version of the user database:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">user@machine</span>:~$ omnidb-server
<span class="ex">Starting</span> OmniDB server...
<span class="ex">Checking</span> port availability...
<span class="ex">Starting</span> server OmniDB 2.4.0 at 0.0.0.0:8000.
<span class="ex">User</span> database version 2.4.0 is already matching server version.
<span class="ex">Press</span> Ctrl+C to exit</code></pre></div>
<p>Future releases of OmniDB will contain the <strong>user database migration</strong> SQL commands required to upgrade the user database, if necessary. This way user data is not lost by upgrading OmniDB. Imagine the following scenario: you use OmniDB 2.4.0 now and you decide to upgrade it to newest release 2.5.0, for example. After the upgrade, when you start OmniDB server, it will apply the changes version 2.5.0 requires. So you will see something like that:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">user@machine</span>:~$ omnidb-server
<span class="ex">Starting</span> OmniDB server...
<span class="ex">Checking</span> port availability...
<span class="ex">Starting</span> server OmniDB 2.4.0 at 0.0.0.0:8080.
<span class="ex">Starting</span> migration of user database from version 2.4.0 to version 2.5.0
<span class="ex">OmniDB</span> successfully migrated user database from version 2.4.0 to version 2.5.0
<span class="ex">Press</span> Ctrl+C to exit</code></pre></div>
<h4 id="omnidb-configuration-file"><span class="header-section-number">2.0.0.5</span> OmniDB configuration file</h4>
<p>Starting on version 2.1.0, OmniDB server comes with a configuration file <code>omnidb.conf</code> that enables the user to specify parameters such as port and listening address. Also, 2.1.0 enables us to start the server with SSL, this requires a certificate and is configured in the same configuration file.</p>
<p>Starting on version 2.4.0, this file is located in <code>~/.omnidb/omnidb-server/omnidb.conf</code> in the user home directory.</p>
<h4 id="omnidb-in-the-browser"><span class="header-section-number">2.0.0.6</span> OmniDB in the browser</h4>
<p>Now that the web server is running, you may access OmniDB browser-based app on your favorite browser. Type in address bar: <code>localhost:8000</code> and hit <code>Enter</code>. If everything went fine, you shall see a page like this:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_002.png" /></p>
<p>Now you know that OmniDB is running correctly. In the next chapters, we will see how to login for the first time, how to create an user and to utilize OmniDB.</p>
<h1 id="creating-users-and-connections"><span class="header-section-number">3</span> Creating Users and Connections</h1>
<h4 id="logging-in-as-user-admin"><span class="header-section-number">3.0.0.1</span> Logging in as user <em>admin</em></h4>
<p>OmniDB comes only with the user <em>admin</em>. If you are using the server version, the first thing to do is sign in as <em>admin</em>, the default password is <em>admin</em>. You don't need to login in the app version.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_003.png" /></p>
<p>The next window is the initial window. We will talk about it later.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_004.png" /></p>
<h4 id="creating-another-user"><span class="header-section-number">3.0.0.2</span> Creating another user</h4>
<p>Click on the <em>Users</em> icon on the upper right corner. It will open a popup that allows the current OmniDB super user to create a new OmniDB user.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_005.png" /></p>
<p>After clicking on the <em>Users</em> icon the tool inserts a new user called <em>user2</em> (if that is the first user after <em>admin</em>).</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_006.png" /></p>
<p>You will have to change the <em>username</em> and <em>password</em>. Check if you want this new user to be a <em>super user</em>. This user management window is only seem by super users. When you are done, click on the <em>Save Data</em> button inside the popup.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_007.png" /></p>
<p>You can create as many users as you want, edit existing users and also delete users by clicking on the red cross at the actions column. Now you can logout.</p>
<h4 id="signing-in-as-the-new-user"><span class="header-section-number">3.0.0.3</span> Signing in as the new user</h4>
<p>Let us sign in as the user we just created.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_008.png" /></p>
<p>And we can see the window again. Note that now there is no <em>Users</em> icon, because the <em>test</em> user is not a super user. Go ahead and click on <strong>Connections</strong> on the upper left corner. You will see a popup like this:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_009.png" /></p>
<h4 id="creating-connections"><span class="header-section-number">3.0.0.4</span> Creating connections</h4>
<p>OmniDB C# version supported several DBMS. At the moment, OmniDB Python version, or <code>OmniDB 2.0</code>, supports only PostgreSQL and Oracle. More DBMS support is being added as you read this.</p>
<p>We will now create two connections to PostgreSQL databases and one connection to an Oracle database. To create the connections you have to click on the button <em>New Connection</em> and then choose the connection and fill the other fields. After filling all the fields for both connections, click on the <em>Save Data</em> button.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_010.png" /></p>
<p>For each connection there is an <em>Actions</em> column where you can delete, test and select them. Go ahead and test one of the PostgreSQL connections.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_011.png" /></p>
<p>Notice a pop-up appears with the message <em>fe_sendauth: no password supplied</em>. This is happening because OmniDB does not store the database user password on disk. Not having any password at hand, OmniDB will try to connect without one, thus trying to take advantage of automatic authentication methods that might be in place: <code>trust</code> method, <code>.pgpass</code> file, and so on. As the database server replies with an error not allowing the user to connect, then OmniDB understands a password is required and asks it to the user. When the user types a password in this popup, the password is encrypted and stored in memory.</p>
<p>After you type the password and hit <em>Enter</em>, if the connection to the database is successful you will see a confirmation pop-up.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_012.png" /></p>
<p>But, if you have trouble of any kind connecting to your PostgreSQL database, the same popup will remain showing the error OmniDB got.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_013.png" /></p>
<p>For Oracle, the behavior is similar. When OmniDB first tries to connect to an Oracle database without a password, you will see a message like this:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_115.png" /></p>
<p>If you have any trouble connection to your Oracle database, the same popup will remain showing the error OmniDB got:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_116.png" /></p>
<p>Finally, in the connections grid, if you click on the <em>Select Connection</em> action, OmniDB will open it in a new <strong>Connection Outer Tab</strong> as we can see in the next chapter.</p>
<h1 id="managing-databases"><span class="header-section-number">4</span> Managing Databases</h1>
<p>After creating a connection you can select it by clicking in the <em>Select Connection</em> action in the connections grid. You will see that the connection will be represented by a kind of outer tab called a <em>Connection Tab</em>. And this whole area is called the <em>Workspace Window</em>.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_014.png" /></p>
<h4 id="sections-of-the-workspace-window"><span class="header-section-number">4.0.0.1</span> Sections of the <em>Workspace</em> window</h4>
<p>This interface has several elements:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_015.png" /></p>
<ul>
<li><strong>1) Connections</strong>: Opens a popup with the <em>Connections</em> grid</li>
<li><strong>2) Outer Tabs</strong>: OmniDB lets you work with several databases at the same time. Each database will be accessible through an <em>outer tab</em>. Outer tabs also can host miscellaneous connection-independent features, like the <em>Snippets</em> feature</li>
<li><strong>3) Options</strong>: Shows the current user logged in, and also links for <em>user settings</em>, <em>query history</em>, <em>information</em> and <em>logout</em>.</li>
</ul>
<h4 id="connection-outer-tab"><span class="header-section-number">4.0.0.2</span> Connection Outer Tab</h4>
<p>So, the outer table named <em>Test</em> has this name because of the alias we put in the connection to the <code>testdb</code>. This tab is a <em>Connection Outer Tab</em>. Notice the little tab with a cross besides the <em>Test</em> outer tab. This allows you to create a new outer tab that will automatically be a <em>Connection Outer Tab</em>. However, the <em>Snippet Outer Tab</em> is fixed and will always be the first.</p>
<p>A new <em>Connection Outer Tab</em> will always automatically point to the first connection on your list of database connections. Or, if you clicked on the <em>Select Connection</em> action, it will point to the selected connection. Observe the elements inside of this tab:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_016.png" /></p>
<ul>
<li><strong>1) Connection Selector</strong>: Shows all connections and lets the user select the current one</li>
<li><strong>2) Tree of Structures</strong>: Displays a hierarchical tree where you can navigate through the database elements</li>
<li><strong>3) Inner Tabs</strong>: Allows the user to execute actions in the current database. There are several kinds of inner tabs for the current database. By clicking on the last small tab with a cross, you can add a new tab. A new tab always will be a <em>Query Tab</em>, where you can write any kind of SQL statement</li>
<li><strong>4) Inner Tab Content</strong>: Can vary depending on the kind of inner tab. The figure shows a <em>Query Tab</em> and in this case the content will be an <em>SQL Editor</em>, with syntax highlight and autocomplete</li>
<li><strong>5) Inner Tab Actions</strong>: Can vary depending on the kind of inner tab. For a <em>Query Tab</em>, they are <em>Execute</em>, <em>Format</em>, <em>Explain</em> and <em>Explain Analyze</em></li>
<li><strong>6) Inner Tab Results</strong>: A <em>Query Tab</em>, after you click in the <em>Execute Button</em> or type the execute shortcut (<code>Alt-Q</code>), will show a grid with the query results in the <em>Data</em> subtab. If the query calls a function that raises messages, those will be shown in the <em>Messages</em> subtab. If instead of <em>Execute</em> you clicked in <em>Explain</em> or <em>Explain Analyze</em>, the explain plan for the query will be shown in the <em>Explain</em> subtab.</li>
</ul>
<h4 id="working-with-databases"><span class="header-section-number">4.0.0.3</span> Working with databases</h4>
<p>Take a look at your connections selector. OmniDB always points to the first available connection but you can change it by clicking on the selector.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_017.png" /></p>
<p>Select the <em>DellStore</em> connection. Now go to the tree right below the selector and click to expand the root node <em>PostgreSQL</em>.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_018.png" /></p>
<p>Bear in mind that every 30 minutes you keep without performing actions on the database, will trigger a <em>Authentication</em> popup, meaning that the password that OmniDB has encrypted and stored in memory is now expired. As explained before, this is important for your database security. After you type the correct password, you will see the PostgreSQL node now shows the PostgreSQL version and also was expanded, showing the current database connection and also instance wide elements: <em>Databases</em>, <em>Tablespaces</em>, <em>Roles</em> and <em>Replication Slots</em>.</p>
<p>Go ahead and expand the <em>Schemas</em> node. You will see all schemas in the current database (in case of PostgreSQL, <code>TOAST</code> and temp schemas are not shown).</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_019.png" /></p>
<p>Now click to expand the schema <code>public</code>. You will see different kinds of elements contained in this schema.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_020.png" /></p>
<p>Now click to expand the node <em>Tables</em>, and you will see all tables contained in the schema <code>public</code>. Expand any table and you will see its columns, primary key, foreign keys, constraints, indexes, rules, triggers and partitions.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_021.png" /></p>
<p>In order to view records inside a table, right click it and choose <em>Data Actions &gt; Query Data</em>.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_022.png" /></p>
<p>Notice that OmniDB opens a new SQL editor with a simple query to list table records. The records are displayed in a grid right below the editor. This grid can be controlled with keyboard as if you were using a spreadsheet manager. You can also copy data from single cells or block of cells (that can be selected with the keyboard or mouse) and paste on any spreadsheet manager.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_023.png" /></p>
<p>You can edit the query on the SQL editor, writing simple or more complex queries. To execute, click on the action button or hit the keystroke <code>Ctrl-Q</code>. If the results exceed 50 registers, then extra buttons <em>Fetch More</em> and <em>Fetch All</em> will appear. More details in the next chapters.</p>
<h4 id="working-with-multiple-tabs-inside-the-same-connection"><span class="header-section-number">4.0.0.4</span> Working with multiple tabs inside the same connection</h4>
<p>Inside a single connection, you can create several inner tabs by clicking on the last little tab with a cross. Each new inner tab will be a <em>Query Tab</em>.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_024.png" /></p>
<p>On OmniDB, you can execute several SQL statements and procedures in parallel. When it is executing, an icon will be shown in the tab to indicate its current state. If some process is finished and it is not in the current tab, that tab will show a green icon indicating the routine being executed there is now finished.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_025.png" /></p>
<p>By clicking in the <em>Cancel button</em>, you can cancel a process running inside the database.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_026.png" /></p>
<p>You can also drag and drop a tab to change its order. This works with both inner and outer tabs.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_027.png" /></p>
<p>Additionally, you can use keyboard shortcuts to manage inner tabs (SQL Query) and outer tabs (Connection):</p>
<ul>
<li><strong>Ctrl-Insert</strong>: Insert a new inner tab</li>
<li><strong>Ctrl-Delete</strong>: Removes an inner tab</li>
<li><strong>Ctrl-&lt;</strong>: Change focus to inner tab at left</li>
<li><strong>Ctrl-&gt;</strong>: Change focus to inner tab at right</li>
<li><strong>Ctrl-Shift-Insert</strong>: Insert a new outer tab</li>
<li><strong>Ctrl-Shift-Delete</strong>: Removes an outer tab</li>
<li><strong>Ctrl-Shift-&lt;</strong>: Change focus to outer tab at left</li>
<li><strong>Ctrl-Shift-&gt;</strong>: Change focus to outer tab at right</li>
</ul>
<p>Starting from OmniDB version 2.3.0, all SQL Query tabs are automatically saved whenever you execute them. Even if you close OmniDB window or browser tab, they are already stored in OmniDB <em>User Database</em>. They will be automatically restored when you open OmniDB again (if you are using app), open it in another browser window (if you are using server), or even if you clicked in the <em>Connections</em> window or logged out. Removing an outer tab or inner tab by the interface makes it permanently deleted, so it will not be restored.</p>
<h1 id="creating-changing-and-removing-tables"><span class="header-section-number">5</span> Creating, Changing and Removing Tables</h1>
<h4 id="creating-tables"><span class="header-section-number">5.0.0.1</span> Creating tables</h4>
<p>OmniDB has a table creation interface that lets you configure columns, constraints and indexes. A couple of observations should be mentioned:</p>
<ul>
<li>Most DBMS automatically create indexes when primary keys and unique constraints are created. Because of that, the indexes tab is only available after creating the table.</li>
<li>Each DBMS has its unique characteristics and limitations regarding table creation and the OmniDB interface reflects these limitations. For instance, SQLite does not allow us to change existing columns and constraints. Because of that, the interface lets us change only table name and add new columns when dealing with SQLite databases (it is still not the case in OmniDB Python version, as it currently supports only PostgreSQL databases).</li>
</ul>
<p>We will create example tables (<em>Customer</em> and <em>Address</em>) in the <code>testdb</code> database we connected to earlier. Right click on the <strong>Tables</strong> node and select the <strong>Create Table</strong> action:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_028.png" /></p>
<p>We will create the table <em>Customer</em> with a primary key that will be referenced by the table <em>Address</em>:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_029.png" /></p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_030.png" /></p>
<p>Click on the <em>Save Changes</em> button. Right-click the <em>Tables</em> tree node and click <em>Refresh</em>. Note how the table appers in the <em>Tables</em> tree node:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_031.png" /></p>
<p>Now create the table <em>Address</em> with a primary key and a foreign key:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_032.png" /></p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_033.png" /></p>
<p>Don't forget to click on the <em>Save Changes</em> button when done. At this point we have two tables in schema <code>public</code>. The schema structure can be seen with the graph feature by right clicking on the schema <code>public</code> node of the tree and selecting <em>Render Graph &gt; Simple Graph</em>:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_034.png" /></p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_035.png" /></p>
<p>And this is what the <em>Complete Graph</em> looks like:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_036.png" /></p>
<h4 id="editing-tables"><span class="header-section-number">5.0.0.2</span> Editing tables</h4>
<p>OmniDB also lets you edit existing tables (always following DBMS limitations). To test this feature we will add a new column to the table <em>Customer</em>. To access the alter table interface just right click the table node and select the action <em>Table Actions &gt; Alter Table</em>:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_037.png" /></p>
<p>Add the column <em>cust_age</em> and save:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_038.png" /></p>
<p>The interface is capable of detecting errors that may occur during alter table operations, showing the command and the error that occurred. To demonstrate it we will try to add the column <em>cust_name</em>, which already belongs to this table:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_039.png" /></p>
<h4 id="removing-tables"><span class="header-section-number">5.0.0.3</span> Removing tables</h4>
<p>In order to remove a table just right click the table node and select the action <em>Table Actions &gt; Drop Table</em>:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_040.png" /></p>
<h1 id="managing-table-data"><span class="header-section-number">6</span> Managing Table Data</h1>
<p>The tool allows us to edit records contained in tables through a very simple and intuitive interface. Given that only a few DBMS have unique identifiers for table records, we opted to allow data editing and removal only for tables that have a primary key. Tables that do not have it can only receive new records.</p>
<p>To access the record editing interface, right click the table node and select the action <em>Data Actions &gt; Edit Data</em>:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_041.png" /></p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_042.png" /></p>
<p>The interface has a SQL editor where you can filter and order records. To prevent that the interface requests too many records, there is a field that limits the number of records to be displayed. The records grid has column names and data types. Columns that belong to the primary key have a key icon next to their names.</p>
<p>The row of the grid that have the symbol <code>*</code> is the row to add new records. Let us insert some records in the table <code>Customer</code>:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_043.png" /></p>
<p>After saving, the records will be inserted and can be edited (only because this table has a primary key). Let’s change the <em>cust_name</em> of some of the existing records:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_044.png" /></p>
<p>Tables can have fields with values represented by very long strings. To help edit these fields, OmniDB has an interface that can be accessed by right clicking the specific cell:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_045.png" /></p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_046.png" /></p>
<p>The interface detects errors that may occur during operations related to records. To demonstrate, let us insert two records with existing <code>cust_id</code> (primary key):</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_047.png" /></p>
<p>It shows which commands tried to be executed and the respective errors.</p>
<p>To complete this chapter, let’s add some records to the <em>Address</em> table:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_048.png" /></p>
<h1 id="writing-sql-queries"><span class="header-section-number">7</span> Writing SQL Queries</h1>
<p>The tool comes with a tab system where each tab contains a SQL editor, an action button, an indent button, a field to select the type of command and a space to display the result.</p>
<p>The SQL editor has a feature that helps a lot when creating new queries: SQL code completion. With this feature it is possible to autocomplete columns contained in a table referenced by an alias. To open the autocomplete interface you just have to type the alias and then the dot character:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_049.png" /></p>
<p>Besides autocompleting table columns the editor also searches for columns contained in subqueries:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_050.png" /></p>
<p>If the query raises an error, OmniDB will show the error message in the <em>Data</em> tab and the cursor will be placed in the position indicated by the error message:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_051.png" /></p>
<p>When the query is successful, OmniDB shows the number of records returned by the query, the start time and the duration of the query. The <em>Data</em> tab will show a data grid with the records records returned by the query.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_052.png" /></p>
<p>Just like in the record editing interface each cell can be visualized separately by right clicking it.</p>
<p>If you click on the <em>Indent SQL</em> button, OmniDB will reorganize the SQL text to make it prettier:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_053.png" /></p>
<h1 id="visualizing-query-plans"><span class="header-section-number">8</span> Visualizing Query Plans</h1>
<p>OmniDB 2.2.0 introduced a very useful feature: graphical query plan visualization. This may come in handy when writing or optimizing queries, since it allows you to easily identify performance bottlenecks in your SQL query.</p>
<p>For this feature, <em>SQL Query</em> inner tab shows 2 buttons: <em>Explain</em> (magnifier in orange circle button )and <em>Explain Analyze</em> (magnifier in green circle button).</p>
<h4 id="textual-visualization"><span class="header-section-number">8.0.0.1</span> Textual visualization</h4>
<p>When you click the <em>Explain</em> button, OmniDB will execute an <code>EXPLAIN</code> command in your query. Initial visualization is <em>textual</em> and will show exactly the output of the <code>EXPLAIN</code> command, but with colored bars representing the estimated cost. The higher the cost, the darker and wider the bar.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_054.png" /></p>
<p>When you click the <em>Explain Analyze</em> button, OmniDB will execute an <code>EXPLAIN ANALYZE</code> command in your query. Beware that this command will really execute the query. Also, the textual visualization will show much more information, and the costs are not estimated as in those provided by the <code>EXPLAIN</code> command; they are real costs.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_055.png" /></p>
<h4 id="tree-visualization"><span class="header-section-number">8.0.0.2</span> Tree visualization</h4>
<p>Both <em>Explain</em> and <em>Explain Analyze</em> modes also can graphically represent the textual output into a <em>tree</em> diagram. Each circle represent a node executed by the query plan, and the larger the circle, the higher the cost.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_056.png" /></p>
<p>When queries become more and more complex, also its query plan can be very complex. With such queries (like the <em>check bloat</em> query we executed below) the tree visualization can be very interesting:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_057.png" /></p>
<p>The query plan visualization component allows you to easily switch between textual and 2 tree visualizations, which can be zoomed in and out.</p>
<h1 id="visualizing-data"><span class="header-section-number">9</span> Visualizing Data</h1>
<p>This feature displays a graph with nodes representing tables and edges representing table relationships with foreign keys. Using the mouse, the user is able to zoom in, zoom out, and drag and drop nodes to change its position.</p>
<p>There are two types of graphs: <em>Simple Graph</em> and <em>Complete Graph</em>.</p>
<h4 id="simple-graph"><span class="header-section-number">9.0.0.1</span> Simple graph</h4>
<p>To access it just right click the root node of the tree and then select the action <em>Render Graph &gt; Simple Graph</em>:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_058.png" /></p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_059.png" /></p>
<h4 id="complete-graph"><span class="header-section-number">9.0.0.2</span> Complete graph</h4>
<p>This graph displays tables with all its columns and respective data types. Additionally, edges now are labeled with information about the specific foreign key. To access it just right click the root node of the tree and then select the action <em>Render Graph &gt; Complete Graph</em>:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_060.png" /></p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_061.png" /></p>
<h1 id="managing-other-elements"><span class="header-section-number">10</span> Managing other Elements</h1>
<p>With the exception of tables, all PostgreSQL structures are possible to be managed with the use of <em>SQL templates</em>. This gives the user more power than using graphical forms to manipulate structures.</p>
<p>For example, let's consider the sequences inside the schema <code>public</code> of the database <code>testdb</code>. To create a new sequence, right click on the <em>Sequences</em> node, and choose <em>Create Sequence</em>.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_062.png" /></p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_063.png" /></p>
<p>After you change the name of the sequence, you can uncomment other command options and set them accordingly to your needs. When the entire command looks fine, just execute it and the new sequence will be created:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_064.png" /></p>
<p>With right click on an existing sequence, you can alter or drop it. It will work the same way as the creation, by using a SQL template for the user to change.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_065.png" /></p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_066.png" /></p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_067.png" /></p>
<h1 id="additional-features"><span class="header-section-number">11</span> Additional Features</h1>
<h4 id="sql-history"><span class="header-section-number">11.0.0.1</span> SQL History</h4>
<p>Every interaction the user does with every database is logged in OmniDB's <em>SQL History</em>. To access it you need to click on the icon with an <em>H</em> on the upper right corner. OmniDB will open an inner tab with all actions in a paginated grid.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_068.png" /></p>
<p>Each action shows date time it started, the time it ended, the duration, the status and the command. As every grid in OmniDB, you can right click on the command and click <em>View Content</em>, where another pop-up will open showing the content in a larger text editor.</p>
<h4 id="user-settings"><span class="header-section-number">11.0.0.2</span> User Settings</h4>
<p>Also in the upper right corner, by clicking in the gear-like icon, OmniDB will open the <em>User Settings</em> pop-up. It is composed by two tabs:</p>
<ul>
<li><p><strong>User</strong>: Allows the user to change its password. More user settings will be added in the future.</p></li>
<li><p><strong>Editor</strong>: Allows the user to change the font size of the SQL Editor, and also change the entire OmniDB theme. There are a lot of OmniDB themes, each of them change the syntax highlight color of the editor. They are also categorized in light and dark themes. A light theme is the default; a dark theme will change the entire interface of OmniDB.</p></li>
</ul>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_069.png" /></p>
<p>Every change in user settings require that you either:</p>
<ul>
<li>Refresh the page, if you are using OmniDB server and the interface through a web browser; or</li>
<li>Open and close OmniDB, if you are using OmniDB app.</li>
</ul>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_070.png" /></p>
<h4 id="contextual-help"><span class="header-section-number">11.0.0.3</span> Contextual Help</h4>
<p>Most of tree nodes (generally grouping ones like <em>Schemas</em> or <em>Tables</em>) offer contextual help. This feature can be accessed by right-clicking the tree node. When you click in the <em>Doc: ...</em> option, OmniDB will open an inner tab showing a web browser pointing to the specific page in the online <strong>PostgreSQL Documentation</strong>. Also, it will redirect to the specific page considering the PostgreSQL version you are connected to.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_071.png" /></p>
<h4 id="snippets"><span class="header-section-number">11.0.0.4</span> Snippets</h4>
<p><em>Workspace Window</em> has a fixed outer tab with an useful feature called <em>Snippets</em>. With this feature you can store queries, command instructions and any other kinds of text you want. You can also structure the snippets in a directory tree the way you want. All directories and snippets you create are stored inside of <code>omnidb.db</code> user database and persist when you upgrade OmniDB.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_127.png" /></p>
<h4 id="backend-management"><span class="header-section-number">11.0.0.5</span> Backend Management</h4>
<p>By right-clicking in the tree root node, then moving mouse pointer to <em>Monitoring</em> and then clicking on <em>Backends</em>, the user can see all activities going on in the database. Some information are hidden for normal users, only database superusers are allowed to see.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_174.png" /></p>
<p>By clicking in the red <em>X</em> in the <em>Actions</em> column, you can terminate the backend. A confirmation popup will appear.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_175.png" /></p>
<h4 id="properties-and-ddl"><span class="header-section-number">11.0.0.6</span> Properties and DDL</h4>
<p>By clicking on most of objects in the treeview (tables, sequences, views, roles, databases, etc), the user will be able to see a very comprehensive list of properties of the object.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_176.png" /></p>
<p>In the other panel called <em>DDL</em>, the user will be able to see the SQL DDL source code that can be used to re-create the object. The user can copy this text and paste it wherever he/she wants.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_177.png" /></p>
<h1 id="omnidb-config-tool"><span class="header-section-number">12</span> OmniDB Config Tool</h1>
<p>Every installation of OmniDB also comes with a small CLI utility called <em>OmniDB Config</em>. It will have a different file name, depending on the way you installed OmniDB:</p>
<ul>
<li>If you are using a tarball or zip package, it is called <strong>omnidb-config</strong>, for both server and app versions;</li>
<li>If you used an installer (like the .deb file) of server version, it is called <strong>omnidb-config-server</strong>;</li>
<li>If you used an installer of app version, it is called <strong>omnidb-config-app</strong>.</li>
</ul>
<p>Despite having different names, the utility does exactly the same. If you used an installer, it will be put in your <code>$PATH</code>.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">user@machine</span>:~$  omnidb-config-app --help
<span class="ex">Usage</span>: omnidb-config-app [options]

<span class="ex">Options</span>:
  <span class="ex">--version</span>             show program<span class="dt">\&#39;</span>s version number and exit
  <span class="ex">-h</span>, --help            show this help message and exit
  <span class="ex">-c</span> username password, --createsuperuser=username password
                        <span class="ex">create</span> super user: -c username password
  <span class="ex">-a</span>, --vacuum          databases maintenance
  <span class="ex">-r</span>, --resetdatabase   reset databases</code></pre></div>
<h4 id="create-super-user"><span class="header-section-number">12.0.0.1</span> Create super user</h4>
<p>Option <code>-c</code> allows you to create a new super user, without needing to open OmniDB interface.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">user@machine</span>:~$ omnidb-config-app -c william password
<span class="ex">Creating</span> superuser...
<span class="ex">Superuser</span> created.</code></pre></div>
<h4 id="vacuum"><span class="header-section-number">12.0.0.2</span> Vacuum</h4>
<p>OmniDB has two databases:</p>
<ul>
<li><code>omnidb.db</code>: Stores all users and connections, and other OmniDB related stuff;</li>
<li><em>Sessions database</em>: Stores Django user sessions.</li>
</ul>
<p>Both databases are SQLite, so it can be useful to vacuum them sometimes to reduce file size. This can be done with the <code>-a</code> option.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">user@machine</span>:~$ omnidb-config-app -a
<span class="ex">Vacuuming</span> OmniDB database...
<span class="ex">Done.</span>
<span class="ex">Vacuuming</span> Sessions database...
<span class="ex">Done.</span></code></pre></div>
<h4 id="reset-database"><span class="header-section-number">12.0.0.3</span> Reset database</h4>
<p>If you wish to wipe out all OmniDB information and get a clean database as it was just installed, you can use the <code>-r</code> option. Use it with caution!</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">user@machine</span>:~$ omnidb-config-app -r
<span class="ex">***</span> ATENTION *** ALL USERS DATA WILL BE LOST
<span class="ex">Would</span> you like to continue? (y/n) <span class="ex">y</span>
<span class="ex">Cleaning</span> users...
<span class="ex">Done.</span>
<span class="ex">Cleaning</span> sessions...
<span class="ex">Vacuuming</span> OmniDB database...
<span class="ex">Done.</span>
<span class="ex">Vacuuming</span> Sessions database...
<span class="ex">Done.</span></code></pre></div>
<h1 id="writing-and-debugging-plpgsql-functions"><span class="header-section-number">13</span> Writing and Debugging PL/pgSQL Functions</h1>
<h4 id="introduction-1"><span class="header-section-number">13.0.0.1</span> Introduction</h4>
<p>PostgreSQL is more than a RDBMS engine. It is a developing platform. It provides a very powerful and flexible programming language called <code>PL/pgSQL</code>. Using this language you can write your own <em>user-defined functions</em> to achieve abstraction levels and procedural calculations that would be difficult to achieve with plain SQL (and sometimes impossible to achieve without context-switching with the application). While you always could develop and manage your own functions within OmniDB, it is a recent feature that allows you to also <em>debug</em> your own functions.</p>
<p>OmniDB 2.3.0 introduces this great feature: a debugger for PL/pgSQL functions. It was implemented by scratch and takes advantage of hooks, an extensibility in PostgreSQL’s source code that allows us to perform custom actions when specific events are triggered in the database. For the debugger we use hooks that are triggered when PL/pgSQL functions are called, and each statement is executed.</p>
<p>This requires the user to install a binary library called <code>omnidb_plugin</code> and enable it in PostgreSQL's config file. The debugger also uses a special schema with special tables to control the whole debugging process. This can be manually created or with an extension.</p>
<p>For more details on the installation, please refer to the <a href="https://github.com/OmniDB/OmniDB/blob/master/omnidb_plugin/README.md">instructions</a>. Also please read the notes in this document, to be aware that currently there are some limitations.</p>
<p>After successfully installing the debugger, you will se a schema called <code>omnidb</code> in your database. Also, if you compiled the debugger yourself, you can install it as a PostgreSQL extension, and in this case it will appear under the <em>Extensions</em> tree node.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_072.png" /></p>
<h4 id="writing-functions"><span class="header-section-number">13.0.0.2</span> Writing functions</h4>
<p>In the <code>public</code> schema, right-click the <code>Functions</code> node and click on <em>Create Function</em>. It will open a <em>SQL Query</em> inner tab, already containing a SQL Template to help you create your first PL/pgSQL function.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_073.png" /></p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_074.png" /></p>
<p>You can refer to PostgreSQL documentation on how to write user-defined functions. No need to open a new browser tab: just right-click the <em>Functions</em> node and click on <em>Doc: Functions</em> to view the documentation inside OmniDB.</p>
<p>For now, let us replace this SQL template entirely for the source code below:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">CREATE</span> <span class="kw">OR</span> <span class="kw">REPLACE</span> <span class="kw">FUNCTION</span> public.fnc_count_vowels (p_input text)
RETURNS <span class="dt">integer</span> LANGUAGE plpgsql <span class="kw">AS</span>
$function$
<span class="kw">DECLARE</span>
  str text;
  ret <span class="dt">integer</span>;
  i   <span class="dt">integer</span>;
  len <span class="dt">integer</span>;
  tmp text;
<span class="kw">BEGIN</span>
  str := <span class="fu">upper</span>(p_input);
  ret := <span class="dv">0</span>;
  i := <span class="dv">1</span>;
  len := <span class="fu">length</span>(p_input);
  <span class="kw">WHILE</span> i &lt;= len <span class="kw">LOOP</span>
    <span class="kw">IF</span> <span class="fu">substr</span>(str, i, <span class="dv">1</span>) <span class="kw">in</span> (<span class="st">&#39;A&#39;</span>, <span class="st">&#39;E&#39;</span>, <span class="st">&#39;I&#39;</span>, <span class="st">&#39;O&#39;</span>, <span class="st">&#39;U&#39;</span>) <span class="kw">THEN</span>
      <span class="kw">SELECT</span> pg_sleep(<span class="dv">1</span>) <span class="kw">INTO</span> tmp;
      ret := ret + <span class="dv">1</span>;
    <span class="kw">END</span> <span class="kw">IF</span>;
    i := i + <span class="dv">1</span>;
  <span class="kw">END</span> <span class="kw">LOOP</span>;
  <span class="kw">RETURN</span> ret;
<span class="kw">END</span>;
$function$</code></pre></div>
<p>This will create a function called <code>fnc_count_vowels</code> inside the schema <code>public</code>. This function takes a text argument called <code>p_input</code> and counts how many vowels there are in this <em>string</em>. Then returns this count.</p>
<p>To create the function, execute the command in the SQL Query inner tab. If successful, the function will appear under the <em>Functions</em> tree node (you can refresh it by right-clicking and then clicking in <em>Refresh</em>). By expanding the function node as well, you can see its return type and its argument.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_075.png" /></p>
<p>Now let us execute this new function for the first time. Open a simple SQL Query inner tab and execute the following SQL query:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> public.fnc_count_vowels(<span class="st">&#39;The quick brown fox jumps over the lazy dog.&#39;</span>)</code></pre></div>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_076.png" /></p>
<p>Note how the query returns a single value, containing the number of vowels in the text. Note also how the query took several seconds to finish; this is caused by the <code>pg_sleep</code> we put in the source code of the function <code>fnc_count_vowels</code>.</p>
<p>By right-clicking the function node, you can see there are actions to edit and drop it. As you probably guessed, each action will open SQL Query inner tabs with handy SQL templates in them. But the most interesting action right now is <em>Debug Function</em>. Go ahead and click it!</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_077.png" /></p>
<h4 id="debugging-functions"><span class="header-section-number">13.0.0.3</span> Debugging functions</h4>
<p>The debugger is a specific inner tab composed of a SQL editor that will show the process step by step on top of the function source code, and 5 tabs to manage and view different parts of the debugger.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_078.png" /></p>
<ul>
<li><strong>Parameters</strong>: Before the debugging process starts, the user must provide all the parameters in this tab. Parameters must be provided exactly the same way you would provide them if you were executing the function in plain SQL, quoting strings for instance;</li>
<li><strong>Variables</strong>: This grid displays the current value of each variable that exists in the current execution context, it will be updated with every step;</li>
<li><strong>Result</strong>: When the function ends, this tab will show the result of the function call. It could be empty, a single value or even a set of rows;</li>
<li><strong>Messages</strong>: Messages returned explicitly by <code>RAISE</code> commands or even automatic messages from PostgreSQL will be presented in this tab;</li>
<li><strong>Statistics</strong>: At the end of the debugging process, a chart depicting execution times for each line in the function body will be presented in this tab. Additionally, the SQL editor will be updated with a set of colors representing a heat map, from blue to red, according to the max duration of each line.</li>
</ul>
<p>Now let us start debugging this function. First thing to do is to fill <em>every</em> parameter in the <em>Parameters</em> tab:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_079.png" /></p>
<p>Then click on the <em>Start</em> button. Note how OmniDB automatically goes to the <em>Variables</em> tab, which is the interesting tab now that the function is being debugged. The argument <code>p_input</code> is now called <code>$1</code>, indicating the first argument of the function. Also note the variable <code>found</code>, which is a PostgreSQL reserved variable that indicates whether or not a query has returned values inside of the function.</p>
<p>Also note that OmniDB points to the first line of the source code of the function, highlighting it in green. This is the line that is about to be executed.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_080.png" /></p>
<p>Now click in the first button below the SQL editor. It is the <em>Step Over</em> button, and it means that OmniDB will execute the next statement and stop right after it.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_081.png" /></p>
<p>Note how the variable <code>str</code> has the value assigned to it during execution of line 9. Right now OmniDB is about to execute line 10, showing the current execution state.</p>
<p>Now that you know how to step over, let us speed up things a little bit. Click on the header of the line 20, the last line of code. By doing this, you just placed a <em>breakpoint</em>. The debugger interface allows you to place one breakpoint at a time.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_082.png" /></p>
<p>After setting a breakpoint, you can click in the second button, <em>Resume</em>. OmniDB will carry on with the debugging process until it reaches the line of code with the breakpoint. This may take a while because of the <code>pg_sleep</code> commands we put in the source code. Note that if you click this button without previously setting a breakpoint, OmniDB will execute the entire function to the end.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_083.png" /></p>
<p>Observe the values for each variable. We can see that the value of <code>ret</code> is 11 even before the function finishes. Also note that OmniDB does not remove the breakpoint you placed. To do that, you can click in the breakpoint little icon. Now hit <em>Resume</em> again. Let us see now what happens when the function finishes.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_084.png" /></p>
<p>OmniDB will go automatically to the <em>Statistics</em> tab, which shows 2 interesting features:</p>
<ul>
<li><em>Sum of Duration per Line of Code Chart</em>: in the bottom, a chart represents total duration of the function distributed in the lines of code. With this chart, you can easily spot bottlenecks in your code. In our example, it was line 15, which we deliberately put a <code>pg_sleep(1)</code> call;</li>
<li><em>Colored lines of source code</em>: OmniDB colors the lines accordingly to the numbers seen in the chart. Colors vary from blue (small duration), passing through yellow (medium duration) until red (high duration), as in a <em>temperature</em> diagram.</li>
</ul>
<p>Also note the <em>Total duration</em> message, which shows execution time of the function, without considering the time you spent analyzing it.</p>
<h4 id="inspecting-record-attribute-values"><span class="header-section-number">13.0.0.4</span> Inspecting record attribute values</h4>
<p>An interesting feature that we do not usually see in other debuggers is the ability to inspect each attribute of a variable of type <code>record</code>. OmniDB debugger does that as it is split into different variables, allowing you to see the value and type of each attribute.</p>
<p>To illustrate that, let us create another function, similar to the previous one, but now called <code>fnc_count_vowels2</code>:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">CREATE</span> <span class="kw">OR</span> <span class="kw">REPLACE</span> <span class="kw">FUNCTION</span> public.fnc_count_vowels2 (p_input text)
RETURNS <span class="dt">integer</span> LANGUAGE plpgsql <span class="kw">AS</span>
$function$
<span class="kw">DECLARE</span>
  str text;
  i   <span class="dt">integer</span>;
  len <span class="dt">integer</span>;
  rec <span class="dt">record</span>;
<span class="kw">BEGIN</span>
  str := <span class="fu">upper</span>(p_input);
  i := <span class="dv">1</span>;
  len := <span class="fu">length</span>(p_input);
  <span class="kw">SELECT</span> <span class="dv">0</span> <span class="kw">AS</span> a, <span class="dv">0</span> <span class="kw">AS</span> e, <span class="dv">0</span> <span class="kw">AS</span> i, <span class="dv">0</span> <span class="kw">AS</span> o, <span class="dv">0</span> <span class="kw">AS</span> u <span class="kw">INTO</span> rec;
  <span class="kw">WHILE</span> i &lt;= len <span class="kw">LOOP</span>
    <span class="kw">CASE</span> <span class="fu">substr</span>(str, i, <span class="dv">1</span>)
      <span class="kw">WHEN</span> <span class="st">&#39;A&#39;</span> <span class="kw">then</span> rec.a := rec.a + <span class="dv">1</span>;
      <span class="kw">WHEN</span> <span class="st">&#39;E&#39;</span> <span class="kw">then</span> rec.e := rec.e + <span class="dv">1</span>;
      <span class="kw">WHEN</span> <span class="st">&#39;I&#39;</span> <span class="kw">then</span> rec.i := rec.i + <span class="dv">1</span>;
      <span class="kw">WHEN</span> <span class="st">&#39;O&#39;</span> <span class="kw">then</span> rec.o := rec.o + <span class="dv">1</span>;
      <span class="kw">WHEN</span> <span class="st">&#39;U&#39;</span> <span class="kw">then</span> rec.u := rec.u + <span class="dv">1</span>;
      <span class="kw">ELSE</span> <span class="kw">NULL</span>;
    <span class="kw">END</span> <span class="kw">CASE</span>;
    i := i + <span class="dv">1</span>;
  <span class="kw">END</span> <span class="kw">LOOP</span>;
  <span class="kw">RETURN</span> rec.a + rec.e + rec.i + rec.o + rec.u;
<span class="kw">END</span>;
$function$</code></pre></div>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_084.png" /></p>
<p>Observe how we keep track of every vowel count individually. Now let us start debugging it, using the same text as before (<code>'The quick brown fox jumps over the lazy dog.'</code>):</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_086.png" /></p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_087.png" /></p>
<p>Note from the picture above that PostgreSQL created an internal <em>Case Variable</em>. Also note that the variable <code>rec</code> is not shown in the list of known variables. This is because PostgreSQL still does not know what attributes <code>rec</code> will contain. Let's step over some more steps.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_088.png" /></p>
<p>Right after the execution of line 11, <code>rec</code> variable comes to life and we can see it has 5 attributes: <code>a</code>, <code>e</code>, <code>i</code>, <code>o</code> and <code>u</code>, all of the type <code>int</code> and having initial value <code>0</code>.</p>
<p>Now set a breakpoint in line 23 and click the <em>Resume</em> button.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_089.png" /></p>
<p>See how we can inspect every attribute, observing how many of each vowel the text contain. Now let's finish this function.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_090.png" /></p>
<h1 id="monitoring-dashboard"><span class="header-section-number">14</span> Monitoring Dashboard</h1>
<p>OmniDB 2.4.0 introduces a new cool feature called <em>Monitoring Dashboard</em>. We know a picture is worth a thousand words, so please take a look:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_091.png" /></p>
<p>As you can see, this is a new kind of inner tab showing some charts and grids. This <em>Monitoring</em> inner tab is automatically opened once you expand the tree root node (the <em>PostgreSQL</em> node). You can keep it open or close it at any time. To open it again, right-click the root node and click on <em>Dashboard</em>.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_092.png" /></p>
<p>The dashboard is composed of handy information rectangles called <em>Monitoring Units</em>. Here is an example of Monitoring Unit and its interface elements:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_093.png" /></p>
<ul>
<li><strong>1</strong>: Title of the Monitoring Unit;</li>
<li><strong>2</strong>: Refresh the Monitoring Unit. Depending on the type, clicking on this button will refresh the entire drawing area or just make the chart acquire a new set of values;</li>
<li><strong>3</strong>: Pause the Monitoring Unit;</li>
<li><strong>4</strong>: Interval in seconds for automatic refreshing;</li>
<li><strong>5</strong>: Remove the Monitoring Unit of the Monitoring Dashboard;</li>
<li><strong>6</strong>: Drawing area, that will be different depending on the type of the Monitoring Unit.</li>
</ul>
<h4 id="types-of-monitoring-units"><span class="header-section-number">14.0.0.1</span> Types of Monitoring Units</h4>
<p>Currently there are 3 types of Monitoring Units:</p>
<ul>
<li><strong>Grid</strong>: The most simple kind, just executes a query from time to time and shows the results in a data grid.</li>
</ul>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_094.png" /></p>
<ul>
<li><strong>Chart</strong>: Every time it refreshes, it renders a new complete chart. The old set of values is lost. This is most useful for pie charts, but other kind of charts can be used too.</li>
</ul>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_095.png" /></p>
<ul>
<li><strong>Chart-Append</strong>: Perhaps this is the most useful kind of Monitoring Unit. It is a chart that appends a new set of values every time it refreshes. Line or bar charts fit best for this type. The last 50 set of values are kept by the component client-side to be viewed by the user.</li>
</ul>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_096.png" /></p>
<h4 id="showing-and-hiding-units-in-the-dashboard"><span class="header-section-number">14.0.0.2</span> Showing and hiding units in the dashboard</h4>
<p>If you click in the button <em>Refresh All</em>, then all Monitoring Units will be refreshed at once. You can also remove undesired Monitoring Units by clicking in the <em>Remove</em> button. Let us go ahead and remove all units from the dashboard, making it empty:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_097.png" /></p>
<p>All Monitoring Units that come with OmniDB are open source and available in this <a href="https://github.com/OmniDB/monitors">repository</a> (feel free to contribute). But be aware that some Monitoring Units require the <code>plpythonu</code> script to be installed in the database. Please refer to the instructions specific to your operating system on how to install <code>plpythonu</code> if you desire to use and create Monitoring Units that use <code>plpythonu</code>.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_098.png" /></p>
<p>Now that our dashboard is empty, let us add some units. Click on the <em>Manage Units</em> button.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_099.png" /></p>
<p>Click on the green action to add the Monitoring Units called <em>CPU Usage</em> and <em>Memory Usage</em>. Bear in mind that both units require <code>plpythonu</code> extension in the database. <em>CPU Usage</em> also requires that the tool <code>mpstat</code> should be installed in the server. Also both units are of type <em>Chart-Append</em>. Wait for some seconds and you will have a dashboard like this:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_100.png" /></p>
<p>In a similar way, you can add and remove any unit you want to customize the dashboard the way you want.</p>
<h4 id="writing-custom-monitoring-units-grid"><span class="header-section-number">14.0.0.3</span> Writing custom Monitoring Units: Grid</h4>
<p>OmniDB provides you the power to write your own units and customize existing ones. Everything is done through Python scripts that run inside a sandbox. Beware that units powered by <code>plpythonu</code> can have access to the file system the database user also has access to, and any Monitoring Unit have the same permission as the database user you configured in the Connection.</p>
<p>To create a new Monitoring Unit, click on the <em>Manage Units</em> button in the dashboard, then click on the <em>New Unit</em> button. It will open a new kind of inner tab like this:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_101.png" /></p>
<p>The easiest way to write a custom unit is to use an existing one as template. Go ahead and select the <em>(Grid) Activity</em> template:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_102.png" /></p>
<p>Note how OmniDB fills the <em>Data Script</em> source code. This script is responsible for generating data for the unit every time it refreshes. As a grid unit is nothing else but a grid of data, we can rely on only this script for now.</p>
<p>Now let us take a look at the source code of this template:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> datetime <span class="im">import</span> datetime

data <span class="op">=</span> connection.Query(<span class="st">&#39;&#39;&#39;</span>
<span class="st">    SELECT *</span>
<span class="st">    FROM pg_stat_activity</span>
<span class="st">&#39;&#39;&#39;</span>)

result <span class="op">=</span> {
    <span class="st">&quot;columns&quot;</span>: data.Columns,
    <span class="st">&quot;data&quot;</span>: data.Rows
}</code></pre></div>
<p>It is simple enough. It executes an SQL query into the current connection using the reserved <code>connection</code> variable. Also, the grid unit type expects its results in a JSON variable that must be called <code>result</code> and must have the attributes <code>&quot;columns&quot;</code> (an array of column names) and <code>&quot;data&quot;</code> (an array of rows, each row being an array of values). The <code>connection.Query()</code> function already does the job pretty well, so let us just change the SQL query this way:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> datetime <span class="im">import</span> datetime

data <span class="op">=</span> connection.Query(<span class="st">&#39;&#39;&#39;</span>
<span class="st">    SELECT random() as &quot;Random Number&quot;</span>
<span class="st">&#39;&#39;&#39;</span>)

result <span class="op">=</span> {
    <span class="st">&quot;columns&quot;</span>: data.Columns,
    <span class="st">&quot;data&quot;</span>: data.Rows
}</code></pre></div>
<p>Copy and paste the above Python code into the <em>Data Script</em> text field and then click on the <em>Test</em> (lighting) button:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_103.png" /></p>
<p>Note how the grid was rendered in the preview drawing area. You can click the <em>Test</em> button as many times as you want. Now we will give the unit a name, set a refresh interval and then hit the <em>Save</em> button:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_104.png" /></p>
<p>Click the <em>OK</em> button and then close the edit tab. Our new Monitoring Unit will be in the list of available units. As we created this unit, we can either add it to the dashboard, edit it or remove it. Let us add it to the dashboard (green action):</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_105.png" /></p>
<h4 id="writing-custom-monitoring-units-chart"><span class="header-section-number">14.0.0.4</span> Writing custom Monitoring Units: Chart</h4>
<p>Click in the <em>Manage Units</em> button and then in the <em>New Unit</em> button. This time we will create a Chart Monitoring Unit. So choose <em>(Chart) Database Size</em> as a template.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_106.png" /></p>
<p>The source code of this kind of unit is more complex. There are two scripts:</p>
<ul>
<li><strong>Data Script</strong>: Executed every time the unit is refreshed;</li>
<li><strong>Chart Script</strong>: Executed only at the beginning to build the chart.</li>
</ul>
<p>The chart units are based in the component <a href="http://www.chartjs.org/">Chart.js</a> and each chart type contains a specific JSON structure. The best approach to build new chart units is to start from a template and also check the <a href="http://www.chartjs.org/docs/latest/">Chart.js docs</a> to see every property that can be added to make the output even better for each situation.</p>
<p>Let us take a look at the <strong>Data Script</strong>:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> datetime <span class="im">import</span> datetime
<span class="im">from</span> random <span class="im">import</span> randint

databases <span class="op">=</span> connection.Query(<span class="st">&#39;&#39;&#39;</span>
<span class="st">    SELECT d.datname AS datname,</span>
<span class="st">           round(pg_catalog.pg_database_size(d.datname)/1048576.0,2) AS size</span>
<span class="st">    FROM pg_catalog.pg_database d</span>
<span class="st">    WHERE d.datname not in (&#39;template0&#39;,&#39;template1&#39;)</span>
<span class="st">&#39;&#39;&#39;</span>)

data <span class="op">=</span> []
color <span class="op">=</span> []
label <span class="op">=</span> []

<span class="cf">for</span> db <span class="kw">in</span> databases.Rows:
    data.append(db[<span class="st">&quot;size&quot;</span>])
    color.append(<span class="st">&quot;rgb(&quot;</span> <span class="op">+</span> <span class="bu">str</span>(randint(<span class="dv">125</span>, <span class="dv">225</span>)) <span class="op">+</span> <span class="st">&quot;,&quot;</span> <span class="op">+</span> <span class="bu">str</span>(randint(<span class="dv">125</span>, <span class="dv">225</span>)) <span class="op">+</span> <span class="st">&quot;,&quot;</span> <span class="op">+</span> <span class="bu">str</span>(randint(<span class="dv">125</span>, <span class="dv">225</span>)) <span class="op">+</span> <span class="st">&quot;)&quot;</span>)
    label.append(db[<span class="st">&quot;datname&quot;</span>])

result <span class="op">=</span> {
    <span class="st">&quot;labels&quot;</span>: label,
    <span class="st">&quot;datasets&quot;</span>: [
        {
            <span class="st">&quot;data&quot;</span>: data,
            <span class="st">&quot;backgroundColor&quot;</span>: color,
            <span class="st">&quot;label&quot;</span>: <span class="st">&quot;Dataset 1&quot;</span>
        }
    ]
}</code></pre></div>
<p>Here we can see that the reserved variable <code>connection</code> is still being used to retrieve data from the database. Bear in mind that this variable is always pointing to the current Connection.</p>
<p>This template is for a Pie chart, which contains only one dataset and three arrays for the data:</p>
<ul>
<li><code>data</code>: One value per slice;</li>
<li><code>color</code>: One color per slice;</li>
<li><code>label</code>: One label per slice.</li>
</ul>
<p>This way, <code>data[0]</code>, <code>color[0]</code> and <code>label[0]</code> refer to the first slice, while <code>data[1]</code>, <code>color[1]</code> and <code>label[1]</code> refer to the second slice, and so on.</p>
<p>This script must return a variable called <code>result</code> and also needs to be a JSON like in the above script.</p>
<p>So right now you are probably guessing that you just need to change the SQL query to make the chart behave different. Well, in terms of data and datasets, you guessed right. So let's change the SQL query of this chart to compare sizes of tables of schema <code>public</code>. Also change the references from <code>datname</code> to <code>tablename</code>, as we have changed the column name.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> datetime <span class="im">import</span> datetime
<span class="im">from</span> random <span class="im">import</span> randint

databases <span class="op">=</span> connection.Query(<span class="st">&#39;&#39;&#39;</span>
<span class="st">    SELECT c.relname as tablename,</span>
<span class="st">           round(pg_catalog.pg_total_relation_size(c.oid)/1048576.0,2) AS size</span>
<span class="st">    FROM pg_catalog.pg_class c</span>
<span class="st">    INNER JOIN pg_catalog.pg_namespace n</span>
<span class="st">    ON n.oid = c.relnamespace</span>
<span class="st">    WHERE n.nspname = &#39;public&#39;</span>
<span class="st">      AND c.relkind = &#39;r&#39;</span>
<span class="st">&#39;&#39;&#39;</span>)

data <span class="op">=</span> []
color <span class="op">=</span> []
label <span class="op">=</span> []

<span class="cf">for</span> db <span class="kw">in</span> databases.Rows:
    data.append(db[<span class="st">&quot;size&quot;</span>])
    color.append(<span class="st">&quot;rgb(&quot;</span> <span class="op">+</span> <span class="bu">str</span>(randint(<span class="dv">125</span>, <span class="dv">225</span>)) <span class="op">+</span> <span class="st">&quot;,&quot;</span> <span class="op">+</span> <span class="bu">str</span>(randint(<span class="dv">125</span>, <span class="dv">225</span>)) <span class="op">+</span> <span class="st">&quot;,&quot;</span> <span class="op">+</span> <span class="bu">str</span>(randint(<span class="dv">125</span>, <span class="dv">225</span>)) <span class="op">+</span> <span class="st">&quot;)&quot;</span>)
    label.append(db[<span class="st">&quot;tablename&quot;</span>])

result <span class="op">=</span> {
    <span class="st">&quot;labels&quot;</span>: label,
    <span class="st">&quot;datasets&quot;</span>: [
        {
            <span class="st">&quot;data&quot;</span>: data,
            <span class="st">&quot;backgroundColor&quot;</span>: color,
            <span class="st">&quot;label&quot;</span>: <span class="st">&quot;Dataset 1&quot;</span>
        }
    ]
}</code></pre></div>
<p>Copy and paste the above script into the <em>Data Script</em> field and then hit the <em>Test</em> button:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_107.png" /></p>
<p>Apparently the chart is almost done. We need to fix the title, it still says <em>Database Size</em>, when this chart is about table size. Any information about the format of the chart itself is defined in the <em>Chart Script</em> text field. Let us understand the current source code:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">total_size <span class="op">=</span> connection.ExecuteScalar(<span class="st">&#39;&#39;&#39;</span>
<span class="st">    SELECT round(sum(pg_catalog.pg_database_size(datname)/1048576.0),2)</span>
<span class="st">    FROM pg_catalog.pg_database</span>
<span class="st">    WHERE NOT datistemplate</span>
<span class="st">&#39;&#39;&#39;</span>)

result <span class="op">=</span> {
    <span class="st">&quot;type&quot;</span>: <span class="st">&quot;pie&quot;</span>,
    <span class="st">&quot;data&quot;</span>: <span class="va">None</span>,
    <span class="st">&quot;options&quot;</span>: {
        <span class="st">&quot;responsive&quot;</span>: <span class="va">True</span>,
        <span class="st">&quot;title&quot;</span>:{
            <span class="st">&quot;display&quot;</span>:<span class="va">True</span>,
            <span class="st">&quot;text&quot;</span>:<span class="st">&quot;Database Size (Total: &quot;</span> <span class="op">+</span> <span class="bu">str</span>(total_size) <span class="op">+</span> <span class="st">&quot;)&quot;</span>
        }
    }
}</code></pre></div>
<p>Easy enough. We can make use of the reserved variable <code>connection</code> to retrieve data in the <em>Chart Script</em> too. This is mainly used to put information in the chart title. The variable <code>result</code> must be defined here. Note how its JSON value defines a pie chart and the title. So we just need to change the query and adjust the title, this way:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">total_size <span class="op">=</span> connection.ExecuteScalar(<span class="st">&#39;&#39;&#39;</span>
<span class="st">    SELECT round(sum(pg_catalog.pg_total_relation_size(c.oid)/1048576.0),2) AS size</span>
<span class="st">    FROM pg_catalog.pg_class c</span>
<span class="st">    INNER JOIN pg_catalog.pg_namespace n</span>
<span class="st">    ON n.oid = c.relnamespace</span>
<span class="st">    WHERE n.nspname = &#39;public&#39;</span>
<span class="st">      AND c.relkind = &#39;r&#39;</span>
<span class="st">&#39;&#39;&#39;</span>)

result <span class="op">=</span> {
    <span class="st">&quot;type&quot;</span>: <span class="st">&quot;pie&quot;</span>,
    <span class="st">&quot;data&quot;</span>: <span class="va">None</span>,
    <span class="st">&quot;options&quot;</span>: {
        <span class="st">&quot;responsive&quot;</span>: <span class="va">True</span>,
        <span class="st">&quot;title&quot;</span>:{
            <span class="st">&quot;display&quot;</span>:<span class="va">True</span>,
            <span class="st">&quot;text&quot;</span>:<span class="st">&quot;Table Size (Total: &quot;</span> <span class="op">+</span> <span class="bu">str</span>(total_size) <span class="op">+</span> <span class="st">&quot;)&quot;</span>
        }
    }
}</code></pre></div>
<p>Copy and paste the above Python code into the <em>Chart Script</em>. Then click in the <em>Test</em> button:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_108.png" /></p>
<p>Now that the chart finally works the way we want, we can give it a title, adjust the refresh interval and then click in the <em>Save</em> button. After that we can add it to the dashboard.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_109.png" /></p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_110.png" /></p>
<h4 id="writing-custom-monitoring-units-chart-append"><span class="header-section-number">14.0.0.5</span> Writing custom Monitoring Units: Chart-Append</h4>
<p>Now for the last, but most interesting kind of Monitoring Unit: <em>Chart-Append</em>. It is interesting because there is a wide range of applications for these units, since they keep recent historic data that allows us to see a comparison of values.</p>
<p>Go ahead and add a new chart using <em>(Chart (Append)) Size: Top 5 Tables</em> as template:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_111.png" /></p>
<p>Now take a look at the source code of both <em>Data Script</em> and <em>Chart Script</em>. It is not too different from the Chart units. The dataset creation is a bit more complex as it involves other JSON settings, but that's all.</p>
<p>As an exercise, based on this chart, create another one called <em>Size: Top 20 Tables</em>. It should look like this:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_112.png" /></p>
<p>Now save it and add it to your dashboard:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_113.png" /></p>
<h1 id="logical-replication"><span class="header-section-number">15</span> Logical Replication</h1>
<p>PostgreSQL 10 introduces native logical replication, which uses a publish/subscribe model and so we can create publications on the upstream (or publisher) and subscriptions on downstream (or subscriber). For more details about it, please refer to the <a href="https://www.postgresql.org/docs/10/static/sql-createpublication.html">PostgreSQL</a> <a href="https://www.postgresql.org/docs/10/static/sql-createsubscription.html">documentation</a>.</p>
<p>In this chapter, we will use a 2-node cluster to demonstrate PostgreSQL 10 native logical replication. Note that on each PostgreSQL instance, you need to configure <code>wal_level = logical</code> and also make sure to adjust file <code>pg_hba.conf</code> to grant access to <code>replication</code> between the 2 nodes.</p>
<h4 id="connecting-to-both-nodes"><span class="header-section-number">15.0.0.1</span> Connecting to both nodes</h4>
<p>Let's use OmniDB to connect to both PostgreSQL nodes. First of all, fill out connection info in the connection grid:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_117.png" /></p>
<p>Then select both connections. Note how OmniDB understands it is connected to PostgreSQL 10 and enables a new node in the current connection tree view: it is called <em>Logical Replication</em>. Inside of it, we can see <em>Publications</em> and <em>Subscriptions</em>.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_118.png" /></p>
<h4 id="creating-a-test-table-on-both-nodes"><span class="header-section-number">15.0.0.2</span> Creating a test table on both nodes</h4>
<p>On both nodes, create a table like this:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">CREATE</span> <span class="kw">TABLE</span> customers (
 login text <span class="kw">PRIMARY</span> <span class="kw">KEY</span>,
 full_name text <span class="kw">NOT</span> <span class="kw">NULL</span>,
 registration_date timestamptz <span class="kw">NOT</span> <span class="kw">NULL</span> <span class="kw">DEFAULT</span> now()
)</code></pre></div>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_119.png" /></p>
<h4 id="create-a-publication-on-the-first-machine"><span class="header-section-number">15.0.0.3</span> Create a publication on the first machine</h4>
<p>Inside the connection node, expand the <em>Logical Replication</em> node, then right click in the <em>Publications</em> node, and choose the action <em>Create Publication</em>. OmniDB will open a SQL template tab with the <code>CREATE PUBLICATION</code> command ready for you to make some adjustments and run:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_120.png" /></p>
<p>After adjusting and executing the command, you can right click the <em>Publications</em> node again and click on the <em>Refresh</em> action. You will see that will be created a new node with the same name you gave to the publication. Expanding this node, you will see the details and the tables for the publication:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_121.png" /></p>
<h4 id="create-a-subscription-on-the-second-machine"><span class="header-section-number">15.0.0.4</span> Create a subscription on the second machine</h4>
<p>Inside the connection node, expand the <em>Logical Replication</em> node, then right click in the <em>Subscriptions</em> node, and choose the action <em>Create Subscription</em>. OmniDB will open a SQL template tab with the <code>CREATE SUBSCRIPTION</code> command ready for you to make some adjustments and run:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_122.png" /></p>
<p>After adjusting and executing the command, you can right click the <em>Subscriptions</em> node again and click on the <em>Refresh</em> action. You will see that will be created a new node with the same name you gave to the subscription. Expanding this node, you will see the details, the referenced publications and the tables for the subscription:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_123.png" /></p>
<p>Also, the <code>CREATE SUBSCRIPTION</code> command created a <em>logical replication slot</em> called <code>testsub</code> (the same name as the subscription) in the first machine:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_124.png" /></p>
<h4 id="testing-the-logical-replication"><span class="header-section-number">15.0.0.5</span> Testing the logical replication</h4>
<p>To test the replication is working, let's create some data on the node 1. Right click on the table <code>public.customers</code>, then point to <em>Data Actions</em>, then click on the action <em>Edit Data</em>. In this grid, you are able to add, edit and remove data from the table. Add 2 sample rows, like this:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_125.png" /></p>
<p>Then, on the other node, check if the table <code>public.customers</code> was automatically populated. Right click on the table <code>public.customers</code>, then point to <em>Data Actions</em>, then click on the action <em>Query Data</em>:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_126.png" /></p>
<p>As we can see, both rows created in the first machine were replicated into the second machine. This tell us that the logical replication is working.</p>
<p>Now you can perform other actions, such as adding/removing tables to the publication and creating a new publication that publishes all tables.</p>
<h1 id="pglogical"><span class="header-section-number">16</span> pglogical</h1>
<p><a href="https://www.2ndquadrant.com/en/resources/pglogical/">pglogical</a> is a PostgreSQL extension that provides an advanced logical replication system that serves as a highly efficient method of replicating data as an alternative to physical replication.</p>
<p>In this chapter, we will use a 2-node cluster to demonstrate pglogical with PostgreSQL 10. Note that on each PostgreSQL instance, you need to configure:</p>
<pre class="text"><code>wal_level = &#39;logical&#39;
track_commit_timestamp = on
max_worker_processes = 10   # one per database needed on provider node
                            # one per node needed on subscriber node
max_replication_slots = 10  # one per node needed on provider node
max_wal_senders = 10        # one per node needed on provider node
shared_preload_libraries = &#39;pglogical&#39;</code></pre>
<p>Also make sure to adjust file <code>pg_hba.conf</code> to grant access to <code>replication</code> between the 2 nodes.</p>
<h4 id="connecting-to-both-nodes-1"><span class="header-section-number">16.0.0.1</span> Connecting to both nodes</h4>
<p>Let's use OmniDB to connect to both PostgreSQL nodes. First of all, fill out connection info in the connection grid:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_128.png" /></p>
<p>Then select both connections.</p>
<h4 id="create-pglogical-extension-in-both-nodes"><span class="header-section-number">16.0.0.2</span> Create pglogical extension in both nodes</h4>
<p>pglogical requires an extension to be installed in both nodes. Inside OmniDB, you can create the extension by right clicking on the <em>Extensions</em> node, and choosing the action <em>Create Extension</em>. OmniDB will open a SQL template tab with the <code>CREATE EXTENSION</code> command ready for you to make some adjustments and run:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_129.png" /></p>
<p>After you have created the extension, you need to refresh the root node of the treeview, by right-clicking on it and choosing <em>Refresh</em>. Then you will see that OmniDB already acknowledges the existence of pglogical in this database. However, pglogical is not active yet.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_130.png" /></p>
<h4 id="create-pglogical-nodes"><span class="header-section-number">16.0.0.3</span> Create pglogical nodes</h4>
<p>To activate pglogical in this database, we need to create a pglogical node on each machine. Inside the <em>pglogical</em> node of the treeview, right click <em>Nodes</em>, then choose <em>Create Node</em>. In the SQL template that will open, adjust the node name and the DSN and run the command.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_131.png" /></p>
<p>Then right click <em>Nodes</em> again, but this time choose <em>Refresh</em>. You will see the node you just created. Note how OmniDB understands that this node is local. Expand the local node to see its interface inside. You can manage the interfaces of the nodes using OmniDB too.</p>
<p>Go ahead and expand the <em>Replication Sets</em> node. You can see pglogical default replication sets are already created: <em>ddl_sql</em>, <em>default</em> and <em>default_insert_only</em>. You can also manage replication sets using OmniDB.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_132.png" /></p>
<p>Now create a node on the other machine too. Choose a different name for the node.</p>
<h4 id="create-a-table-on-the-first-machine"><span class="header-section-number">16.0.0.4</span> Create a table on the first machine</h4>
<p>In the first machine, under the <em>Schemas</em> node, expand the <em>public</em> node, then right-click the <em>Tables</em> node and choose <em>Create Table</em>. In the form tab that will open, give the new table a name and some columns. Also add a primary key in the <em>Constraints</em> tab. When done, click in the <em>Save Changes</em> button.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_133.png" /></p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_134.png" /></p>
<h4 id="add-the-new-table-to-a-replication-set-on-the-first-machine"><span class="header-section-number">16.0.0.5</span> Add the new table to a replication set on the first machine</h4>
<p>In the first machine, under the <em>default_insert_only</em> replication set, right click the <em>Tables</em> node and choose <em>Add Table</em>. In the SQL template tab that will open, change the table name in the <em>relation</em> argument and then execute the command.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_135.png" /></p>
<p>Refresh the <em>Tables</em> node to check the table was added to the replication set.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_136.png" /></p>
<h4 id="add-a-subscription-on-the-second-machine"><span class="header-section-number">16.0.0.6</span> Add a subscription on the second machine</h4>
<p>In the second machine, right-click the <em>Subscriptions</em> node and choose <em>Create Subscription</em>. In the SQL template tab that will open, change DSN of the first machine and then execute the command.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_137.png" /></p>
<p>Refresh and expand both <em>Nodes</em> and <em>Subscriptions</em> nodes of the treeview. Note how now the second machine knows about the first machine. Also check the information OmniDB shows about the subscription we just created.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_138.png" /></p>
<p>Also verify that the table <em>public.test_table</em> was created automatically in the second machine:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_139.png" /></p>
<h4 id="add-some-data-in-the-table-on-the-first-machine"><span class="header-section-number">16.0.0.7</span> Add some data in the table on the first machine</h4>
<p>In the first machine, under the <em>Schemas</em> node, expand the <em>public</em> node and the <em>Tables</em> node. Right-click in our table, <em>test_table</em>, move the mouse pointer to <em>Data Actions</em> and then click on <em>Edit Data</em>. Insert some data to the table. When finished, click on the <em>Save Changes</em> button.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_140.png" /></p>
<p>Now let us check the data was replicated. Go to the second machine and right-click the table, move the mouse pointer to <em>Data Actions</em> and then click on <em>Query Data</em>.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_141.png" /></p>
<h4 id="check-if-delete-is-being-replicated"><span class="header-section-number">16.0.0.8</span> Check if delete is being replicated</h4>
<p>In the <em>Edit Data</em> tab in the first machine, remove Pete and Stuart. Click on the button <em>Save Changes</em> when done.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_142.png" /></p>
<p>Check if these 2 rows were deleted in the second machine.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_143.png" /></p>
<p>They were not removed in the second machine because the table <em>public.test_table</em> is in the replication set <em>default_insert_only</em>, that does not replicate <em>updates</em> and <em>deletes</em>.</p>
<h1 id="postgres-bdr"><span class="header-section-number">17</span> Postgres-BDR</h1>
<p><a href="https://www.2ndquadrant.com/en/resources/bdr/">Postgres-BDR</a> (or just <strong>BDR</strong>, for short) is an open source project from 2ndQuadrant that provides multi-master features for PostgreSQL.</p>
<p>In this chapter, we will use a 2-node cluster to demonstrate Postgres-BDR 9.4. Note that on each PostgreSQL instance, you need to configure:</p>
<pre class="text"><code>wal_level = &#39;logical&#39;
track_commit_timestamp = on
max_worker_processes = 10   # one per database needed on provider node
                            # one per node needed on subscriber node
max_replication_slots = 10  # one per node needed on provider node
max_wal_senders = 10        # one per node needed on provider node
shared_preload_libraries = &#39;bdr&#39;</code></pre>
<p>Also make sure to adjust file <code>pg_hba.conf</code> to grant access to <code>replication</code> between the 2 nodes.</p>
<h4 id="connecting-to-both-nodes-2"><span class="header-section-number">17.0.0.1</span> Connecting to both nodes</h4>
<p>Let's use OmniDB to connect to both PostgreSQL nodes. First of all, fill out connection info in the connection grid:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_144.png" /></p>
<p>Then select both connections.</p>
<h4 id="create-required-extensions"><span class="header-section-number">17.0.0.2</span> Create required extensions</h4>
<p>BDR requires 2 extensions to be installed on each database that should have multi-master capabilities: <code>btree_gist</code> and <code>bdr</code>. Inside OmniDB, you can create both extensions by right clicking on the <em>Extensions</em> node, and choosing the action <em>Create Extension</em>. OmniDB will open a SQL template tab with the <code>CREATE EXTENSION</code> command ready for you to make some adjustments and run:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_145.png" /></p>
<p>You need to create both extensions <code>btree_gist</code> and <code>bdr</code> on both nodes.</p>
<h4 id="create-the-bdr-group-in-the-first-node"><span class="header-section-number">17.0.0.3</span> Create the BDR group in the first node</h4>
<p>With both extensions installed, you can refresh the root node of the OmniDB tree view. A new <em>BDR</em> node will appear just inside your database. You can expand this node to see some informations about BDR:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_146.png" /></p>
<p>As you can see, BDR is not active yet. In the first node, we need to create a <em>BDR group</em>. The other nodes will join this group later.</p>
<p>To create a BDR group, right click in the <em>BDR</em> node. In the SQL template, adjust the node name and the node external connection info (the way other nodes will use to connect to this node):</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_147.png" /></p>
<p>After you execute the above command, right click the <em>BDR</em> node and choose <em>Refresh</em>. You will see that now BDR is active in this node, now called <code>node1</code>. If you expand <em>Nodes</em>, you will see that this BDR group has only 1 node:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_148.png" /></p>
<h4 id="join-the-bdr-group-in-the-second-node"><span class="header-section-number">17.0.0.4</span> Join the BDR group in the second node</h4>
<p>Now let's move to the other node. You can see that BDR is installed but not active yet. To link the two nodes, we will need to make this node join the BDR group that was previously created in the first node:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_149.png" /></p>
<p>And now we can see that the second node has BDR active, his name in the BDR group is <code>node2</code>, and now the BDR group has 2 nodes:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_150.png" /></p>
<h4 id="creating-a-table-in-the-first-node"><span class="header-section-number">17.0.0.5</span> Creating a table in the first node</h4>
<p>Let's create a table in the first node. Expand the <code>public</code> schema, right click the <em>Tables</em> node and choose <em>Create Table</em>. Give the new table a name and add some columns. When done, click in the button <em>Save Changes</em>:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_151.png" /></p>
<p>Now confirm that the table has been created in the first node by right clicking the <em>Tables</em> node and choosing <em>Refresh</em>. Go to the second node, expand the schema <code>public</code>, then expand the <em>Tables</em> node. Note that the table has been replicated from <code>node1</code> to <code>node2</code>. If the table was created in the second node, it would have been created in the first node as well, because in BDR all nodes are masters.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_152.png" /></p>
<h4 id="adding-some-data-in-the-second-node"><span class="header-section-number">17.0.0.6</span> Adding some data in the second node</h4>
<p>While you are at the second node, right click the table <code>bdrtest</code>, point to <em>Data Actions</em> and then click in <em>Edit Data</em>. Add some rows to this table. When finished, click in the <em>Save Changes</em> button.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_153.png" /></p>
<p>Now go to the first node, right click the table, point to <em>Data Actions</em> and then click in <em>Query Data</em>. See how the rows created in <code>node2</code> were automatically replicated into <code>node1</code>.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_154.png" /></p>
<h4 id="adding-some-data-in-the-first-node"><span class="header-section-number">17.0.0.7</span> Adding some data in the first node</h4>
<p>Let's repeat the same procedure above, but instead of inserting rows from the second node, let's insert some rows while connected to the first node. Note how they replicate into the second node in the same way.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_155.png" /></p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_156.png" /></p>
<h1 id="postgres-xl"><span class="header-section-number">18</span> Postgres-XL</h1>
<p><a href="https://www.2ndquadrant.com/en/resources/postgres-xl/">Postgres-XL</a> (or just <strong>XL</strong>, for short) is an open source project from 2ndQuadrant. It is a massively parallel database built on top of PostgreSQL, and it is designed to be horizontally scalable and flexible enough to handle various workloads.</p>
<p>In this chapter, we will use a cluster with 1 GTM and 1 coordinator on the same virtual machine, and 2 data nodes (each data node on a separate virtual machine).</p>
<table>
<thead>
<tr class="header">
<th>Machine</th>
<th>IP</th>
<th>Role</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>xl_gtmcoord</td>
<td>192.168.56.105</td>
<td>GTM and coordinator</td>
<td></td>
</tr>
<tr class="even">
<td>xl_datanode1</td>
<td>192.168.56.106</td>
<td>data node</td>
<td></td>
</tr>
<tr class="odd">
<td>xl_datanode2</td>
<td>192.168.56.107</td>
<td>data node</td>
<td></td>
</tr>
</tbody>
</table>
<p>On each machine, you need to clone Postgres-XL repository and compile it. You also need to set specific XL parameters on file <code>postgresql.conf</code> and make sure all machines are communicating to each other by adjusting file <code>pg_hba.conf</code>. More information on how Postgres-XL works and how to install it on <a href="https://www.postgres-xl.org/documentation/index.html">Postgres-XL documentation</a>. You can also refer to <a href="https://blog.2ndquadrant.com/postgres-xl-omnidb/">this blog post</a>.</p>
<h4 id="preparing-the-nodes"><span class="header-section-number">18.0.0.1</span> Preparing the nodes</h4>
<p>After you have XL up and running on all nodes, you need to let them know about their roles in the cluster and also about the other nodes. On the GTM/coordinator node, run the following as <code>postgres</code> user:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">ALTER</span> NODE coord1 <span class="kw">WITH</span> (<span class="kw">TYPE</span> = <span class="st">&#39;coordinator&#39;</span>, HOST = <span class="st">&#39;localhost&#39;</span>, PORT = <span class="dv">5432</span>);
<span class="kw">CREATE</span> NODE datanode_1 <span class="kw">WITH</span> (<span class="kw">TYPE</span> = <span class="st">&#39;datanode&#39;</span>, HOST = <span class="st">&#39;192.168.56.106&#39;</span>, PORT = <span class="dv">5432</span>);
<span class="kw">CREATE</span> NODE datanode_2 <span class="kw">WITH</span> (<span class="kw">TYPE</span> = <span class="st">&#39;datanode&#39;</span>, HOST = <span class="st">&#39;192.168.56.107&#39;</span>, PORT = <span class="dv">5432</span>);
<span class="kw">SELECT</span> pgxc_pool_reload();</code></pre></div>
<p>On the first data node, run:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">ALTER</span> NODE datanode_1 <span class="kw">WITH</span> (<span class="kw">TYPE</span> = <span class="st">&#39;datanode&#39;</span>, HOST = <span class="st">&#39;localhost&#39;</span>, PORT = <span class="dv">5432</span>);
<span class="kw">CREATE</span> NODE coord1 <span class="kw">WITH</span> (<span class="kw">TYPE</span> = <span class="st">&#39;coordinator&#39;</span>, HOST = <span class="st">&#39;192.168.56.105&#39;</span>, PORT = <span class="dv">5432</span>);
<span class="kw">CREATE</span> NODE datanode_2 <span class="kw">WITH</span> (<span class="kw">TYPE</span> = <span class="st">&#39;datanode&#39;</span>, HOST = <span class="st">&#39;192.168.56.107&#39;</span>, PORT = <span class="dv">5432</span>);
<span class="kw">SELECT</span> pgxc_pool_reload();</code></pre></div>
<p>On the second data node, run:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">ALTER</span> NODE datanode_2 <span class="kw">WITH</span> (<span class="kw">TYPE</span> = <span class="st">&#39;datanode&#39;</span>, HOST = <span class="st">&#39;localhost&#39;</span>, PORT = <span class="dv">5432</span>);
<span class="kw">CREATE</span> NODE coord1 <span class="kw">WITH</span> (<span class="kw">TYPE</span> = <span class="st">&#39;coordinator&#39;</span>, HOST = <span class="st">&#39;192.168.56.105&#39;</span>, PORT = <span class="dv">5432</span>);
<span class="kw">CREATE</span> NODE datanode_1 <span class="kw">WITH</span> (<span class="kw">TYPE</span> = <span class="st">&#39;datanode&#39;</span>, HOST = <span class="st">&#39;192.168.56.106&#39;</span>, PORT = <span class="dv">5432</span>);
<span class="kw">SELECT</span> pgxc_pool_reload();</code></pre></div>
<p>Finally, on the GTM/coordinator, change password of user <code>postgres</code> and create a database:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">ALTER</span> <span class="fu">USER</span> postgres <span class="kw">WITH</span> <span class="kw">PASSWORD</span> <span class="st">&#39;omnidb&#39;</span>;
<span class="kw">CREATE</span> <span class="kw">DATABASE</span> omnidb_tests;</code></pre></div>
<h4 id="connecting-to-the-cluster"><span class="header-section-number">18.0.0.2</span> Connecting to the cluster</h4>
<p>Let's use OmniDB to connect to the coordinator node. First of all, fill out connection info in the connection grid:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_157.png" /></p>
<p>Then select the connection. You will see OmniDB workspace window. Expand the tree root node. Note that OmniDB identifies it is connected to a Postgres-XL cluster and shows a specific node called <em>Postgres-XL</em> just inside the tree root node. Expand this node to see all the nodes we have in our cluster:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_158.png" /></p>
<h4 id="creating-a-hash-table"><span class="header-section-number">18.0.0.3</span> Creating a HASH table</h4>
<p>From the root node, expand <em>Schemas</em>, then <em>public</em>, then right click on the <em>Tables</em> node. Click on <em>Create Table</em>. Name your new table, add some columns to it and do not forget to add a primary key too:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_159.png" /></p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_160.png" /></p>
<p>When done, click on the <em>Save Changes</em> button. Now right click on the <em>Tables</em> node and click on <em>Refresh</em>. You will see the new table created. Expand it to see that there is also a <em>Postgres-XL</em> node inside of it. Check its properties.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_161.png" /></p>
<p>By default, Postgres-XL always try to create a table distributed by HASH. It means that the data will be split into the nodes regularly, through a hash function applied on the specified column. If present, it will use the primary key, or a unique constraint otherwise. If there is no primary key nor unique constraint, Postgres-XL uses the first eligible column. If not possible to distribute by HASH, then Postgres-XL will create the table distributed by ROUNDROBIN, which means that the data will be split in a way that every new row will be added to a different data node.</p>
<p>Now let's add some rows in our new table. Right click on the table, then go to <em>Data Actions</em> and then click on <em>Edit Data</em>. Add some rows and then click on the <em>Save Changes</em> button:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_162.png" /></p>
<p>Right click on the table again, <em>Data Actions</em>, <em>Query Data</em>. You will see that cluster-wide the table has all data inside.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_163.png" /></p>
<p>But how the data was distributed in the data nodes? In the <em>Postgres-XL</em> main node, right click on each node and click on <em>Execute Direct</em>. Adjust the query that will be executed directly into the data node, as you can see below.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_164.png" /></p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_165.png" /></p>
<h4 id="creating-a-replication-table"><span class="header-section-number">18.0.0.4</span> Creating a REPLICATION table</h4>
<p>While HASH distribution is great for write-only and write-mainly tables, REPLICATION distribution is great for read-only and read-mainly tables. However, a table distributed by REPLICATION will store all data in all nodes it is located.</p>
<p>In order to create a REPLICATION table, let us create a new table like we did before:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_166.png" /></p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_167.png" /></p>
<p>Note how by default it was created as a HASH table:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_168.png" /></p>
<p>Let us change the distribution type of the table by right-clicking on the <em>Postgres-XL</em> node inside the table, and then clicking on <em>Alter Distribution</em>. Uncomment the &quot;REPLICATION&quot; line and execute the command:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_169.png" /></p>
<p>You can check the distribution was successfully changed by right-clicking on the <em>Postgres-XL</em> node and clicking on <em>Refresh</em>. The properties will now show <em>Distributed by: replication</em>.</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_170.png" /></p>
<p>Now add some data to the table:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_171.png" /></p>
<p>And then check that all data exist on all data nodes:</p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_172.png" /></p>
<p><img src="https://raw.githubusercontent.com/OmniDB/doc/master/img/image_173.png" /></p>
</body>
</html>
